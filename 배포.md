# 최신 프로젝트 배포시 

로컬 :

※ 프로젝트 루트에서 실행
1. npm run build , git에 업로드
2. docker login -u ruyahct    # 로그인 
   Password(엑세스 토큰) : dckr_pat_BdT5Upzum66XBtJIiu0JNY-wjKM 
3. docker-compose build       # 이미지 생성
4. docker-compose push        # Docker Hub 업로드 (Oracle 에러 나지만 나머지 푸시됨)
(docker-compose push springboot nginx fastapi)

EC2 서버 :

cd ict_project_final
1. git pull                    # 최신 설정 파일 가져오기 (git을 가져오는 이유는 설정파일이 필요하기때문)
   (혹은 설정파일을 서버에 따로 올려도 된다)
2. docker-compose down         # 기존 컨테이너 중지 및 제거
(※주의 docker-compose down -v  # 볼륨까지 전부 삭제)
3. docker-compose pull         # 최신 이미지 다운로드
4. docker-compose up -d oracle # Oracle만 먼저 실행 (메모리 부족 방지)
5. docker-compose logs -f oracle # Oracle 로그 확인 (100% complete 대기)
6. docker-compose up -d        # 나머지 컨테이너 실행
7. docker-compose ps           # 컨테이너 상태 확인
8. docker image prune -f       # 구버전 이미지 삭제

EC2 서버 IP :

43.200.66.80

※ Docker Compose 명령어는 docker-compose.yml 파일이 있는 디렉토리에서 실행해야 합니다
※ docker image prune -a -f  # 모든 이미지 삭제
※ docker system prune -a -f # 모든 정리 (이미지+컨테이너+네트워크+캐시)
※ docker system prune -a -f --volumes # 완전 초기화
df -h # EC2 EBS 볼륨 전체 용량/사용량 확인
docker system df -v # 상세 용량
※ docker volume rm ict_project_final_oracle-data # db삭제 
※ sudo rm -rf ict_project_final # 프로젝트 폴더 삭제 
※ docker-compose logs -f springboot # 스프링부트 로그 
※ docker images # 이미지 확인
※ docker rmi dualauth/passwordless-x1280-single  # 특정 이미지 삭제

패스워드 리스 서버 :

탄력적 IP : 52.78.234.231

docker-compose -f docker-compose.passwordless.yml pull
docker-compose -f docker-compose.passwordless.yml up -d
→ 이미지가 없으면 자동으로 pull하고 컨테이너를 실행합니다.


※ docker-compose -f docker-compose.passwordless.yml down
※ sudo apt install net-tools -y
※ sudo netstat -tuln | grep -E '8080|11040|12010|15010'
# ====================================================================================


# 배포는 이런 흐름으로 진행 되었습니다.

## 배포 구상(아키텍쳐) 
클라이언트
    ↓ (HTTPS)
  nginx (80/443)
    ↓ (HTTP,리버스 프록시)
    ├→ Spring Boot (8080) ← FastAPI (8020)
    └→ React (정적 파일, Spring Boot에서 서빙)

## 1. nginx 설정 파일 및 Dockerfile 준비

nginx - default.conf
Dockerfile.fastapi     
Dockerfile.springboot  
Dockerfile.nginx       
(Dockerfile = 이미지 빌드 명령어를 모아놓은 텍스트 파일)

## 2. docker-compose.yml 작성

4개 서비스 정의: oracle(DB), springboot(백엔드), fastapi(Python API), nginx(프록시)
- build: Dockerfile로 이미지 빌드 설정
- image: Docker Hub에 푸시할 이미지 이름 지정
- environment: .env 파일에서 환경변수 주입 (DB 연결, API 키 등)
- networks: kbo-network로 컨테이너 간 통신
- depends_on: oracle 헬스체크 완료 후 spring/fastapi 시작
- ports: nginx만 80/443 포트 외부 노출
- volumes: oracle-data로 DB 데이터 영구 저장

## 3. 로컬 / 배포용 환경변수 작성

프로젝트 루트의 .env = 배포용 환경변수
springboot폴더의 .env 그리고 python폴더의 .env = 로컬용 환경변수

docker-compose 명령어는 현재 디렉토리에서 docker-compose.yml를 찾고,
같은 디렉토리에 .env 파일이 있으면 자동으로 읽어서 환경변수로 사용.
그리고 배포시(컨테이너 시작시) docker-compose.yml에서 주입한 환경변수가 최우선이됨. 

## 4. Docker 이미지 준비

docker login [username]       # username과 password입력
docker-compose build # 이미지 생성
docker-compose push  # Docker Hub 업로드

## 5. AWS 설정

AWS 인스턴스 생성
인스턴스 유형 : t3.medium
허용보안그룹 : ssh(22) http(80) https(443) 8080 8020(임시)
탄력적 IP (고정 IP) : 43.200.66.80 
EBS 볼륨 설정 : 30GB

## 6. EC2 서버 초기 설정

1. SSH 접속 (mobaxterm)
IP 입력(43.200.66.80), myball-key.pem 키파일 넣고 접속

2. Docker 설치
sudo apt update && sudo apt upgrade -y
sudo apt install -y docker.io
sudo systemctl start docker && sudo systemctl enable docker # 도커 서비스 시작 및 자동 실행 설정
sudo usermod -aG docker ubuntu(사용자명) # 현재 사용자를 도커 그룹에 추가 (sudo 없이 docker 사용)
sudo apt install -y docker-compose # Docker compose 설치
docker --version
docker-compose --version
  
3. git 설치 및 프로젝트 가져오기
sudo apt install -y git 
ssh-keygen -t ed25519 -C "ruyahct@gmail.com" # GitHub용 SSH 키 생성
# Enter 3번 (기본 경로, 비밀번호 없음)
cat ~/.ssh/id_ed25519.pub # 공개키 복사 및 GitHub 등록
# 출력된 내용 복사 → GitHub Settings → SSH and GPG keys → New SSH key
git clone git@github.com:yunhyel2/ict_project_final.git  # SSH용 주소
cd ict_project_final

## 7. 배포 실행

docker-compose pull            # Docker Hub에서 이미지 pull
docker-compose up -d           # 컨테이너 시작
docker-compose logs -f oracle  # Oracle 로그 확인 (100% complete 대기)
docker-compose logs            # 전체 로그 확인
docker stats                   # 메모리 확인

## 8. swap메모리 추가

# 2GB Swap 파일 생성
sudo dd if=/dev/zero of=/swapfile bs=1M count=2048
# (혹은 fallocate 방식식)1GB 스왑 파일 생성 
sudo fallocate -l 1G /swapfile

# 파일 권한 설정 (보안)
sudo chmod 600 /swapfile

# Swap 파일로 포맷
sudo mkswap /swapfile

# Swap 활성화
sudo swapon /swapfile

# 확인
free -h

# 스왑 사용 적극성 조정 (기본값 60, 낮을수록 RAM 선호)
# t3.micro에서는 30 정도 권장
sudo sysctl vm.swappiness=30
echo 'vm.swappiness=30' | sudo tee -a /etc/sysctl.conf

재부팅 후에도 유지하려면:
# /etc/fstab에 추가 (재부팅 후에도 자동 마운트)
echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab

Swap 삭제하려면 (나중에):
sudo swapoff /swapfile
sudo rm /swapfile
# /etc/fstab에서 해당 줄 삭제

=============
# docker run으로 직접 실행 (리소스 제한 포함)
  docker run -d \
    --name kbo-passwordless \
    --cpus="0.8" \
    --cpu-shares=800 \
    --memory="700m" \
    --memory-swap="1g" \
    -p 8143:8143 \
    -p 8080:8080 \
    -p 11040:11040 \
    -p 12010:12010 \
    -p 15010:15010 \
    -e TZ=Asia/Seoul \
    -e DOMAIN=52.78.234.231 \
    -e USE_SSL=false \
    -v passwordless-auth-settings:/opt/x1280/tomcat/conf/passwordless \
    -v passwordless-database:/var/lib/mysql \
    -v passwordless-config:/etc/opt/x1280 \
    --restart unless-stopped \
    dualauth/passwordless-x1280-single
==========
  docker stop kbo-passwordless && docker rm kbo-passwordless && docker volume rm passwordless-auth-settings passwordless-config passwordless-database #삭제시
==========
  docker-compose -f docker-compose.passwordless.yml down -v


최초 배포 시 DB 초기화 
chmod +x init-db.sh
./init-db.sh

**초기화 스크립트가 하는 일:**
1. Oracle KBO 사용자 생성
2. 뉴스 데이터 복원 (백업 파일이 있는 경우)
3. 선수 데이터는 Spring Boot가 자동으로 로드

# ====================================================================================

# 왜 Docker를 사용했나?

## 문제 상황
이 프로젝트는 **4개의 서로 다른 기술 스택**을 사용합니다:
- Oracle 18c (DB)
- Spring Boot (Java 17)
- FastAPI (Python 3.12 + ML 라이브러리)
- Nginx (웹 서버)

## Docker 사용의 핵심 장점

### 1. **서비스 격리 및 독립 관리**
```yaml
services:
  oracle:    # Oracle DB만 독립 실행
  springboot: # Java 환경만 격리
  fastapi:   # Python + ML 라이브러리만 격리
  nginx:     # 웹 서버만 격리
```
→ 각 서비스가 독립된 컨테이너에서 실행되어 **충돌 없이 관리 가능**

### 2. **환경 일관성 보장**
- 로컬(Windows) = 개발 서버 = 운영 서버(Linux) **완전히 동일한 환경**

### 3. **3줄로 끝나는 배포**
```bash
docker-compose pull   # 최신 이미지 다운로드
docker-compose up -d  # 전체 스택 실행
docker image prune -f # 구버전 정리
```
→ 수동 설정 없이 **모든 서비스가 자동으로 시작**

### 4. **빠른 롤백 및 복구**
- 문제 발생 시 이전 버전 이미지로 즉시 되돌리기 가능
- `docker-compose restart` 한 줄로 전체 재시작

### 5. **팀 협업 용이**
- 팀원이 프로젝트 받으면 `docker-compose up -d` 한 줄로 전체 환경 구축 완료
- 복잡한 설치 과정 불필요

### 6. **서버 자원 효율성**
- EC2 서버는 깨끗한 상태 유지 (Docker만 설치)
- 컨테이너로 격리되어 불필요한 파일 축적 방지
---